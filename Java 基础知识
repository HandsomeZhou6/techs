本人学习java时，做的java基础知识总结：

因内容较多，提供原文链接下载。

 

写代码：

1，明确需求。我要做什么？

2，分析思路。我要怎么做？1,2,3。

3，确定步骤。每一个思路部分用到哪些语句，方法，和对象。

4，代码实现。用具体的java语言代码把思路体现出来。

 

学习新技术的四点：

1，该技术是什么？

2，该技术有什么特点(使用注意)：

3，该技术怎么使用。demo

4，该技术什么时候用？test。

-----------------------------------------------------------------------------------------------

一：java概述：

1991 年Sun公司的James Gosling（詹姆斯&middot;高斯林）等人开始开发名称为 Oak 的语言，希望用于控制嵌入在有线电视交换盒、PDA等的微处理器；

1994年将Oak语言更名为Java；

 

Java的三种技术架构:

JAVAEE：Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对web程序开发；

JAVASE：Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础；

JAVAME：Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序；

 

1，JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。

2，JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。

3，配置环境变量：让java jdk\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。

环境变量的配置：

    1）：永久配置方式：JAVA_HOME=%安装路径%\Java\jdk

                      path=%JAVA_HOME%\bin

    2）：临时配置方式：set path=%path%;C:\Program Files\Java\jdk\bin

特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。

classpath的配置:

    1）：永久配置方式：classpath=.;c:\;e:\

    2）：临时配置方式：set classpath=.;c:\;e:\

 

注意：在定义classpath环境变量时，需要注意的情况

如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件；

如果指定了classpath，那么会在指定的目录下查找要运行的类文件。

还会在当前目录找吗？两种情况：

    1）：如果classpath的值结尾处有分号，在具体路径中没有找到运行的类，会默认在当前目录再找一次。

    2）：如果classpath的值结果出没有分号，在具体的路径中没有找到运行的类，不会再当前目录找。

    一般不指定分号，如果没有在指定目录下找到要运行的类文件，就报错，这样可以调试程序。

 

4，javac命令和java命令做什么事情呢？

    要知道java是分两部分的：一个是编译，一个是运行。

    javac：负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。 生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。

    java：负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行.

    一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数.

----------------------------------------------------------------------------------------------

二：java语法基础：

 

1，关键字：其实就是某种语言赋予了特殊含义的单词。

    保留字：其实就是还没有赋予特殊含义，但是准备日后要使用过的单词。

2，标示符：其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0-9、a-z、$、_ ；

    注意：

    1），数字不可以开头。

    2），不可以使用关键字。

3，常量：是在程序中的不会变化的数据。

4，变量：其实就是内存中的一个存储空间，用于存储常量数据。

    作用：方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间。

    特点：变量空间可以重复使用。

什么时候定义变量？只要是数据不确定的时候，就定义变量。

 

变量空间的开辟需要什么要素呢？

    1，这个空间要存储什么数据？数据类型。

    2，这个空间叫什么名字啊？变量名称。

    3，这个空间的第一次的数据是什么？ 变量的初始化值。

 

变量的作用域和生存期:

变量的作用域：

    作用域从变量定义的位置开始，到该变量所在的那对大括号结束；

生命周期：

    变量从定义的位置开始就在内存中活了；

    变量到达它所在的作用域的时候就在内存中消失了；

 

数据类型：

    1）：基本数据类型：byte、short、int、long、float、double、char、boolean

    2）：引用数据类型: 数组、类、接口。

级别从低到高为：byte,char,short(这三个平级)-->int-->float-->long-->double

自动类型转换：从低级别到高级别，系统自动转的；

强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；

 

运算符号：

    1）、算术运算符。

        + - * / %   %:任何整数模2不是0就是1，所以只要改变被模数就可以实现开关运算。

        +:连接符。

        ++,--

    2）、赋值运算符。

        =  += -= *= /= %=

    3）、比较运算符。

        特点：该运算符的特点是：运算完的结果，要么是true，要么是false。

    4）、逻辑运算符。

        &  |  ^  !   &&   ||

        逻辑运算符除了 !  外都是用于连接两个boolean类型表达式。

        &: 只有两边都为true结果是true。否则就是false。

        |:只要两边都为false结果是false，否则就是true

        ^:异或：和或有点不一样。

             两边结果一样，就为false。

             两边结果不一样，就为true.

        & 和 &&区别： & ：无论左边结果是什么，右边都参与运算。

                      &&:短路与，如果左边为false，那么右边不参数与运算。

        | 和|| 区别：|：两边都运算。

                    ||：短路或，如果左边为true，那么右边不参与运算。

    5）、位运算符:用于操作二进制位的运算符。

        &  |  ^

        <<  >>   >>>(无符号右移)

    练习：对两个变量的数据进行互换。不需要第三方变量。

            int a  = 3,b = 5;-->b = 3,a = 5;

            a = a + b; a = 8;

            b = a - b; b = 3;

            a = a - b; a = 5;

            a = a ^ b;//

            b = a ^ b;//b = a ^ b ^ b = a

            a = a ^ b;//a = a ^ b ^ a = b;

        练习：高效的算出 2*8 = 2<<3;

5，语句。

    If  switch  do while   while  for

    这些语句什么时候用？

    1）、当判断固定个数的值的时候，可以使用if，也可以使用switch。

    但是建议使用switch，效率相对较高。

switch(变量){

   case 值:要执行的语句;break;

   …

   default:要执行的语句;

}

 工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了

           就执行哪个case后面的语句，如果没有相同的则执行default后面的语句；

 细节：1）：break是可以省略的，如果省略了就一直执行到遇到break为止；

       2）：switch 后面的小括号中的变量应该是byte,char,short,int四种类型中的一种；

       3）：default可以写在switch结构中的任意位置；如果将default语句放在了第一行，则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。

    2）、当判断数据范围，获取判断运算结果boolean类型时，需要使用if。

    3）、当某些语句需要执行很多次时，就用循环结构。

    while和for可以进行互换。

    区别在于：如果需要定义变量控制循环次数。建议使用for。因为for循环完毕，变量在内存中释放。

 

break:作用于switch ，和循环语句，用于跳出，或者称为结束。

break语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。

 

continue:只作用于循环结构，继续循环用的。

作用：结束本次循环，继续下次循环。该语句单独存在时，下面不可以定义语句，执行不到。

 

6，函 数：为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。

java中的函数的定义格式：

    修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数1，…){

       执行语句；

       return 返回值；

    }

当函数没有具体的返回值时，返回的返回值类型用void关键字表示。

如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。

return的作用：结束函数。结束功能。

 

如何定义一个函数？

    函数其实就是一个功能，定义函数就是实现功能，通过两个明确来完成：

    1）、明确该功能的运算完的结果，其实是在明确这个函数的返回值类型。

    2）、在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型&参数个数)。

函数的作用：

1）、用于定义功能。

2）、用于封装代码提高代码的复用性。

注意：函数中只能调用函数，不能定义函数。

主函数：

    1）、保证该类的独立运行。

    2）、因为它是程序的入口。

    3）、因为它在被jvm调用。

 

函数定义名称是为什么呢？

答：1）、为了对该功能进行标示，方便于调用。

    2）、为了通过名称就可以明确函数的功能，为了增加代码的阅读性。

 

重载的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。

如何区分重载：当函数同名时，只看参数列表。和返回值类型没关系。

 

7，数 组：用于存储同一类型数据的一个容器。好处：可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。

如何在java中表现一个数组呢？两种表现形式。

1）、元素类型[] 变量名 = new 元素类型[元素的个数]；

2）、元素类型[] 变量名 = {元素1，元素2...}；

元素类型[] 变量名 = new 元素类型[]{元素1，元素2...}；

---------------------------------------------------------

//二分查找法。必须有前提：数组中的元素要有序。

    public static int halfSeach_2(int[] arr,int key){

        int min,max,mid;

        min = 0;

        max = arr.length-1;

        mid = (max+min)>>1; //(max+min)/2;

        while(arr[mid]!=key){

            if(key>arr[mid]){

                min = mid + 1;

            }

            else if(key<arr[mid])

                max = mid - 1;

            if(max<min)

                return -1;

            mid = (max+min)>>1;

        }

        return mid;

    }

---------------------------------------------------------

java分了5片内存。

1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。

栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；

    只要数据运算完成所在的区域结束，该数据就会被释放。

堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。

1：每一个实体都有内存首地址值。

2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。

3：垃圾回收机制。

----------------------------------------------------------------------------------------------

三：面向对象：★★★★★

特点：1：将复杂的事情简单化。

2：面向对象将以前的过程中的执行者，变成了指挥者。

3：面向对象这种思想是符合现在人们思考习惯的一种思想。

 

过程和对象在我们的程序中是如何体现的呢？过程其实就是函数；对象是将函数等一些内容进行了封装。

 

匿名对象使用场景：

1：当对方法只进行一次调用的时候，可以使用匿名对象。

2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。

 

在类中定义其实都称之为成员。成员有两种：

1：成员变量：其实对应的就是事物的属性。

2：成员函数：其实对应的就是事物的行为。

 

所以，其实定义类，就是在定义成员变量和成员函数。但是在定义前，必须先要对事物进行属性和行为的分析，才可以用代码来体现。

 

private int age;//私有的访问权限最低，只有在本类中的访问有效。

注意：私有仅仅是封装的一种体现形式而已。

 

私有的成员：其他类不能直接创建对象访问，所以只有通过本类对外提供具体的访问方式来完成对私有的访问，可以通过对外提供函数的形式对其进行访问。

好处：可以在函数中加入逻辑判断等操作，对数据进行判断等操作。

 

总结：开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法。

这个方法一般有两个，规范写法：对于属性 xxx，可以使用setXXX(),getXXX()对其进行操作。

 

类中怎么没有定义主函数呢？

注意：主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。

主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。

 

成员变量和局部变量的区别：

1：成员变量直接定义在类中。

   局部变量定义在方法中，参数上，语句中。

2：成员变量在这个类中有效。

局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。

3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。

局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。

 

构造函数：用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。

特点：

1：该函数的名称和所在类的名称相同。

2：不需要定义返回值类型。

3：该函数没有具体的返回值。

记住：所有对象创建时，都需要初始化才可以使用。

 

注意事项：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。

 

一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，一个类中如果出现多个构造函数。它们的存在是以重载体现的。

 

构造函数和一般函数有什么区别呢？

1：两个函数定义格式不同。

2：构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。

    一般函数，是对象创建后，需要调用才执行，可以被调用多次。

  

什么时候使用构造函数呢？

分析事物时，发现具体事物一出现，就具备了一些特征，那就将这些特征定义到构造函数内。

 

构造代码块和构造函数有什么区别？

构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块，只要对象一建立，就会调用这个代码块。

构造函数：是给与之对应的对象进行初始化，它具有针对性。

 

“Person p = new Person();”

创建一个对象都在内存中做了什么事情？

1：先将硬盘上指定位置的Person.class文件加载进内存。

2：执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。

3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new

4：在该实体空间中进行属性的空间分配，并进行了默认初始化。

5：对空间中的属性进行显示初始化。

6：进行实体的构造代码块初始化。

7：调用该实体对应的构造函数，进行构造函数初始化。（）

8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)

--------------------------------------------------------------------------------------------

封 装（面向对象特征之一）：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。

好处：将变化隔离；便于使用；提高重用性；安全性。

封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。

 

This：代表对象，就是所在函数所属对象的引用。

this到底代表什么呢？哪个对象调用了this所在的函数，this就代表哪个对象，就是哪个对象的引用。

开发时，什么时候使用this呢？

在定义功能时，如果该功能内部使用到了调用该功能的对象，这时就用this来表示这个对象。

 

this 还可以用于构造函数间的调用。

调用格式：this(实际参数)；

this对象后面跟上 .  调用的是成员属性和成员方法(一般方法)；

this对象后面跟上 () 调用的是本类中的对应参数的构造函数。

 

注意：用this调用构造函数，必须定义在构造函数的第一行。因为构造函数是用于初始化的，所以初始化动作一定要执行。否则编译失败。

 

static：★★★ 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。

特点：

1，想要实现对象中的共性数据的对象共享，可以将这个数据进行静态修饰。

2，被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。

3，静态随着类的加载而加载，而且优先于对象存在。

 

弊端：

1，有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。

2，静态方法只能访问静态成员，不可以访问非静态成员。

因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。

3，静态方法中不能使用this，super关键字。

因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。

4，主函数是静态的。

 

什么时候定义静态成员呢？或者说：定义成员时，到底需不需要被静态修饰呢？

成员分两种：

1，成员变量。（数据共享时静态化）

该成员变量的数据是否是所有对象都一样：

如果是，那么该变量需要被静态修饰，因为是共享的数据。

如果不是，那么就说这是对象的特有数据，要存储到对象中。

2，成员函数。（方法中没有调用特有数据时就定义成静态）

    如果判断成员函数是否需要被静态修饰呢？

    只要参考，该函数内是否访问了对象中的特有数据：

    如果有访问特有数据，那方法不能被静态修饰。

    如果没有访问过特有数据，那么这个方法需要被静态修饰。

 

成员变量和静态变量的区别：

1，成员变量所属于对象，所以也称为实例变量。

静态变量所属于类，所以也称为类变量。

2，成员变量存在于堆内存中。

静态变量存在于方法区中。

3，成员变量随着对象创建而存在，随着对象被回收而消失。

静态变量随着类的加载而存在，随着类的消失而消失。

4，成员变量只能被对象所调用。

静态变量可以被对象调用，也可以被类名调用。

所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。

 

静态的注意：静态的生命周期很长。

静态代码块：就是一个有静态关键字标示的一个代码块区域，定义在类中。

作用：可以完成类的初始化，静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。

 

Public：访问权限最大。

static：不需要对象，直接类名即可。

void：主函数没有返回值。

Main：主函数特定的名称。

(String[] args)：主函数的参数，是一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是 new String[0]。

 

jvm默认传递的是长度为0的字符串数组，我们在运行该类时，也可以指定具体的参数进行传递。可以在控制台，运行该类时，在后面加入参数。参数之间通过空格隔开。jvm会自动将这些字符串参数作为args数组中的元素，进行存储。

 

静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块 &agrave; 构造代码块 &agrave; 构造函数；

 

生成Java帮助文档：命令格式：javadoc –d 文件夹名 –auther –version *.java

/**     //格式

*类描述

*@author 作者名

*@version 版本号

*/

/**

*方法描述

*@param  参数描述

*@return  返回值描述

*/

---------------------------------------------------------------------------------------------

设计模式：解决问题最行之有效的思想。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

 

java中有23种设计模式：

单例设计模式：★★★★★

解决的问题：保证一个类在内存中的对象唯一性。

比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。

 

Runtime()方法就是单例设计模式进行设计的。

 

如何保证对象唯一性呢？

思想：

1，不让其他程序创建该类对象。

2，在本类中创建一个本类对象。

3，对外提供方法，让其他程序获取这个对象。

 

步骤：

1，因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象；

2，就在类中创建一个本类的对象；

3，定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控）

 

代码体现：

1，私有化构造函数；

2，创建私有并静态的本类对象；

3，定义公有并静态的方法，返回该对象。

---------------------------------------------

//饿汉式

class Single{

    private Single(){} //私有化构造函数。

private static Single s = new Single(); //创建私有并静态的本类对象。

    public static Single getInstance(){ //定义公有并静态的方法，返回该对象。

        return s;

    }

}

---------------------------------------------

//懒汉式:延迟加载方式。

class Single2{

    private Single2(){}

private static Single2 s = null;

    public static Single2 getInstance(){

        if(s==null)

            s = new Single2();

        return s;

    }

}

-------------------------------------------------------------------------------------------------

继 承（面向对象特征之一）

好处：

1：提高了代码的复用性。

2：让类与类之间产生了关系，提供了另一个特征多态的前提。

 

父类的由来：其实是由多个类不断向上抽取共性内容而来的。

java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。

 

单继承：一个类只能有一个父类。

多继承：一个类可以有多个父类。

 

为什么不支持多继承呢？

因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。

但是java支持多重继承。A继承B  B继承C  C继承D。

多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。

所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。

 

简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。

 

子父类出现后，类中的成员都有了哪些特点：

1：成员变量。

     当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。

     如果想要调用父类中的属性值，需要使用一个关键字：super

     This：代表是本类类型的对象引用。

     Super：代表是子类所属的父类中的内存空间引用。

     注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。

2：成员函数。

当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：覆盖(复写，重写)

什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。

3：构造函数。

发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?

原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super();

super(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。

为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)

因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。

 

注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();

如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。

如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。

 

问题：super()和this()是否可以同时出现的构造函数中。

两个语句只能有一个定义在第一行，所以只能出现其中一个。

 

super()或者this():为什么一定要定义在第一行？

因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。

 

继承的细节：

什么时候使用继承呢？

当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。

英文书中，所属关系：" is a "

注意：不要仅仅为了获取其他类中的已有成员进行继承。

 

所以判断所属关系，可以简单看，如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。

 

细节二：

在方法覆盖时，注意两点：

1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。

2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)

 

继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。

这时如何解决问题呢？介绍一个关键字，final:最终。

 

final特点：

1：这个关键字是一个修饰符，可以修饰类，方法，变量。

2：被final修饰的类是一个最终类，不可以被继承。

3：被final修饰的方法是一个最终方法，不可以被覆盖。

4：被final修饰的变量是一个常量，只能赋值一次。

 

    其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。

    不加final修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。

 

抽象类: abstract

抽象：不具体，看不明白。抽象类表象体现。

在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。

抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。

 

抽象类的特点：

1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。

2：抽象方法只定义方法声明，并不定义方法实现。

3：抽象类不可以被创建对象(实例化)。

4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。

 

抽象类的细节：

1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。

2：抽象类中是否可以定义非抽象方法？

    可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。

3：抽象关键字abstract和哪些不可以共存？final , private , static

4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。

-----------------------------------------------------------------------------------------------

模板方法设计模式：

解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。

abstract class GetTime{

    public final void getTime(){ //此功能如果不需要复写，可加final限定

        long start = System.currentTimeMillis();

        code(); //不确定的功能部分，提取出来，通过抽象方法实现

        long end = System.currentTimeMillis();

        System.out.println("毫秒是："+(end-start));

    }

    public abstract void code(); //抽象不确定的功能，让子类复写实现

}

class SubDemo extends GetTime{

    public void code(){ //子类复写功能方法

        for(int y=0; y<1000; y++){

            System.out.println("y");

        }

    }

}
