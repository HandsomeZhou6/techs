技术笔记：

面试干货：	https://www.cnblogs.com/java1024/p/9022989.html

Redis的两个典型应用场景		http://emacoo.cn/backend/spring-redis/ 
	场景1：数据缓存  	
	场景2：共享Session

JPA(Java Persistence API)是Sun官方提出的Java持久化规范

linux定时备份mysql并同步到其它服务器

RabbitMQ详解		
	消息中间件最主要的作用是解耦	
	分布式事务的支持
	RPC的调用等

springboot
	定时任务
	邮件服务
	mybatis多数据源最简解决方案
	mongodb多数据源的使用
	服务提供与调用eureka服务注册中心
	熔断器Hystrix
	配置中心服务化和高可用
	配置中心和消息总线（配置中心终结版）
	使用Spring Cloud Bus自动刷新配置

断路器:
很好理解, 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 
这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN). 
这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN).
Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 
避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.

****************************************************

jvm系列:如何优化Java GC
	表1：GC优化需要考虑的JVM参数
	类型			参数				描述
	堆内存大小		-Xms				启动JVM时堆内存的大小
					-Xmx				堆内存最大限制
	新生代空间大小	-XX:NewRatio		新生代和老年代的内存比
					-XX:NewSize			新生代内存大小
					-XX:SurvivorRatio	Eden区和Survivor区的内存比
					
	在进行GC优化最常用参数是-Xms、-Xmx、-XX:NewRatio
	Xms和-Xmx参数通常是必须的，所以-XX:NewRatio的值将对GC性能产生重要的影响。
	用-XX:PermSize和-XX:MaxPermSize参数来进行设置永久代内存大小。
	
	只有当出现OutOfMemoryError错误时你才需要去设置永久代内存。

如果分析结果显示运行GC的时间只有0.1-0.3秒，那么就不需要把时间浪费在GC优化上，
但如果运行GC的时间达到1-3秒，甚至大于10秒，那么GC优化将是很有必要的。

*********************************************************

设计模式
	单例模式：
		饿汉
		懒汉（静态方法，方法加锁，双重检查锁定，静态内部类）

工厂模式：
	1. 简单工厂模式(Simple Factory) 
		简单工厂模式不是23种里的一种，简而言之，就是有一个专门生产某个产品的类。
		比如下图中的鼠标工厂，专业生产鼠标，给参数0，生产戴尔鼠标，给参数1，生产惠普鼠标。
	2. 工厂方法模式(Factory Method) 
		工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。
		戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。
		生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。
		后续直接调用鼠标工厂.生产鼠标()即可
	3. 抽象工厂模式(Abstract Factory) 
		抽象工厂模式也就是不仅生产鼠标，同时生产键盘。
		也就是PC厂商是个父类，有生产鼠标，生产键盘两个接口。
		戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。
		创建工厂时，由戴尔工厂创建。
		后续工厂.生产鼠标()则生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘。

代理模式	https://www.cnblogs.com/cenyu/p/6289209.html

静态代理
	需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.
	1.优点：可以做到在不修改目标对象的功能前提下,对目标功能扩展.
	2.缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.

动态代理
	jdk代理，即接口代理
		1.代理对象,不需要实现接口，但是目标对象一定要实现接口
		2.代理对象的生成利用JDK的API,动态的在内存中构建代理对象，需要指定目标对象实现的接口的类型
		3.动态代理也叫做:JDK代理,接口代理

	Cglib代理
	JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.
	Cglib子类代理实现方法:
		1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入spring-core-3.2.5.jar即可.
		2.引入功能包后,就可以在内存中动态构建子类
		3.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.

在Spring的AOP编程中:
如果加入容器的目标对象有实现接口,用JDK代理
如果目标对象没有实现接口,用Cglib代理

策略模式
简单工厂模式和策略模式的区别
1、工厂模式根据条件生产出产品给客户端用。而策略模式是客户端使用传参给Context的策略（你也可以理成产品），
   传入策略的不同，调用同样方法得到的结果也不同。
2、工厂模式：客户端是使用工厂类生产的对象进行操作，策略模式：客户端使用自己传给Context的策略的对象进行操作。

***************************************************************

多线程、锁机制、并发
一般而言，并发的安全性也就是我们常说的线程安全。

在命令行下执行命令：jps -l	查看死锁
jstack -l 5204		生成虚拟机当前时刻的线程快照

避免死锁的常见方法
1、避免一个线程同时获取多个锁
2、避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
3、尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。

四种线程池
	单线程
	固定数量
	缓存
	定时任务
	
多线程吐血整理    	https://www.cnblogs.com/GarfieldEr007/p/5746362.html

synchronized关键字的作用域	（不能被继承）
	某个对象实例内，synchronized aMethod(){},不同的对象实例的synchronized方法是不相干扰的
	某个类的范围，synchronized static aStaticMethod{},对类的所有对象实例起作用
	用于方法中的某个区块中synchronized(this){/*区块*/},作用域是当前对象，只对这个区块的资源实行互斥访问
	
Java 并发编程——Executor框架和线程池原理		https://www.cnblogs.com/NeilZhang/p/8955126.html	

volatile关键字
	当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。
	如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。
	而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。

***************************************************************

数据库性能优化	https://blog.csdn.net/yzllz001/article/details/54848513

优化法则归纳为5个层次：
	1、  减少数据访问（减少磁盘访问）
	2、  返回更少数据（减少网络传输或磁盘访问）
	3、  减少交互次数（减少网络传输）
	4、  减少服务器CPU开销（减少CPU及内存开销）
	5、  利用更多资源（增加资源）
	
SQL语句优化:

	---减少数据访问
		（查询）
		查询尽量使用索引,创建并使用正确的索引
		尽量不要做全表扫描 
		慎用子查询和Union All ，尽量用 union all 代替 union
		多表join时尽量用小表去join大表
		尽量防止模糊
		尽量多表join查询代替子查询
		用EXISTS替代IN、用NOT EXISTS替代NOT IN
		用EXISTS替换DISTINCT
		用>=替代> 
		sql语句用大写的；因为oracle总是先解析sql语句，把小写的字母转换成大写的再执行
		避免在索引列上使用IS NULL和IS NOT NULL
		尽量把字段设置为NOT NULL
	
	---返回更少的数据
		1.分页查询：
			Mysql:
				SELECT * FROM t ORDER BY PACK_ID LIMIT 10;
				SELECT * FROM t ORDER BY PACK_ID LIMIT 0,5;
				SELECT * FROM t ORDER BY PACK_ID LIMIT 5,5;

			Oracle:
				SELECT * FROM t  ORDER BY id;
				SELECT * FROM ( SELECT t.*, ROWNUM FROM t ) WHERE ROWNUM BETWEEN 1 AND 5;
				SELECT * FROM ( SELECT t.*, ROWNUM FROM t where ROWNUM<=5) WHERE ROWNUM >=1;
				SELECT * FROM ( SELECT t.*, row_number() over (ORDER BY t.id) FROM t ) WHERE ROWNUM BETWEEN 1 AND 5;
		2.只返回需要的字段,通过去除不必要的返回字段可以提高性能,尽量用列名代替*
			优点：
				1、减少数据在网络上传输开销
				2、减少服务器数据处理开销
				3、减少客户端内存占用
				4、字段变更时提前发现问题，减少程序BUG
				5、如果访问的所有字段刚好在一个索引里面，则可以使用纯索引访问提高性能。
			缺点：
				增加编码工作量
				
	---减少交互次数		
		1.In List
			首先大部份数据库都会有SQL长度和IN里个数的限制，如ORACLE的IN里就不允许超过1000个值。
			一般IN里面的值个数超过20个以后性能基本没什么太大变化，也特别说明不要超过100，
			超过后可能会引起执行计划的不稳定性及增加数据库CPU及内存成本，这个需要专业DBA评估。
		2.设置Fetch Size
			fetchsize并不会存在一个最优的固定值，因为整体性能与记录集大小及硬件平台有关，
			注意，fetchsize不能设置太大，如果一次取出的数据大于JVM的内存会导致内存溢出，
			所以建议不要超过1000，太大了也没什么性能提高，反而可能会增加内存溢出的危险。
		3.使用存储过程
			大型数据库一般都支持存储过程，合理的利用存储过程也可以提高系统性能。
			个人观点：普通业务逻辑尽量不要使用存储过程，定时性的ETL任务或报表统计函数可以根据团队资源情况采用存储过程处理。·
		4.优化业务逻辑
	
	（写操作）
	批量操作，减少与数据库交互次数
	
	---减少数据库服务器CPU运算
		大量复杂运算在客户端处理
		排序操作会消耗较多的 CPU 资源，所以减少排序可以在缓存命中率高等IO能力足够的场景下会较大影响SQL的响应时间。
		对于MySQL来说，减少排序有多种办法，
		比如：
			上面误区中提到的通过利用索引来排序的方式进行优化
			减少参与排序的记录条数
			非必要不对数据进行排序
		
 SQL什么条件不会使用索引
	 不等于操作不能使用索引
	 经过普通运算或函数运算后的索引字段不能使用索引
	 含前导模糊查询的Like语法不能使用索引
	 B-TREE索引里不保存字段为NULL值记录，因此IS NULL不能使用索引
	 Oracle在做数值比较时需要将两边的数据转换成同一种数据类型，如果两边数据类型不同时会对字段值隐式转换，相当于加了一层函数处理，所以不能使用索引
	 给索引查询的值应是已知数据，不能是未知字段值
	 查询条件中第一个字段不能使用索引，那整个查询也不能使用索引

建索引的字段应满足以下条件：
	1、字段出现在查询条件中，并且查询条件可以使用索引；
	2、语句执行频率高，一天会有几千次以上；
	3、通过字段条件可筛选的记录集很小，那数据筛选比例是多少才适合？
	这个没有固定值，需要根据表数据量来评估，以下是经验公式，可用于快速评估：
	小表(记录数小于10000行的表)：筛选比例<10%；

不适合建索引的字段
		描述备注
		大字段

如何知道SQL是否使用了正确的索引？
	简单SQL可以根据索引使用语法规则判断，复杂的SQL不好办，判断SQL的响应时间是一种策略，
	但是这会受到数据量、主机负载及缓存等因素的影响，有时数据全在缓存里，可能全表访问的时间比索引访问时间还少。
	要准确知道索引是否正确使用，需要到数据库中查看SQL真实的执行计划，

******************************************************************

数据库事务

四大特性：
	原子性	一个事务内的操作全部成功或全部失败回滚
	一致性	事务必须使数据库从一个一致性状态变换到另一个一致性状态
	隔离性	当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，
			不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
	持久性	事务一旦被提交了，那么对数据库中的数据的改变就是永久性的
	
隔离级别：
	串行化	可重复读	读已提交	读未提交
	注：Oracle只有串行化和读已提交两种隔离级别

默认隔离级别：
	Mysql	可重复读		Oracle	读已提交
	
不考虑隔离性可能产生的问题：
	脏读		某一事务读取了另一个事务未提交的脏数据
	不可重复读	不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
	幻读		某一事务修改一批数据后，另一个事务新增数据。幻读针对的是一批数据整体
	
设置隔离级别：
	设置数据库的隔离级别一定要是在开启事务之前！
	
	注：
	对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；
	对于JDBC操作数据库来说，一个Connection对象相当于一个链接，
	而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。
	
******************************************************************
	
Nginx

负载均衡调度算法

	分发请求、解决跨域问题、安全隔离层、存放静态资源。
	
	weight轮询（默认）：
		接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，
		某一台后端服务器宕机，nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 
		这种方式下，可以给不同的后端服务器设置一个权重值（weight）
	ip_hash：
		每个请求按照发起客户端的ip的hash结果进行匹配，
		这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，
		这也在一定程度上解决了集群部署环境下session共享的问题。
	fair：
		智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，
		响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；
		结合了前两者的优点的一种调度算法。但是需要注意的是nginx默认不支持fair算法，
		如果要使用这种调度算法，请安装upstream_fair模块
	url_hash：
		按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。、
		
******************************************************************

Redis

redis是一种高级的key:value存储系统，其中value支持五种数据类型：

1.字符串（strings）
	set mystr "hello world!" //设置字符串类型
	get mystr //读取字符串类型
	
2.字符串列表（lists）
	lists的常用操作包括LPUSH、RPUSH、LRANGE等
	//新建一个list叫做mylist，并在列表头部插入元素"1"
	> lpush mylist "1" 
	//列出mylist中从编号0到编号1的元素
	> lrange mylist 0 1 
	
3.字符串集合（sets）
	//向集合myset中加入一个新元素"one"
	> sadd myset "one"
	//列出集合myset中的所有元素
	> smembers myset 
	//判断元素1是否在集合myset中，返回1表示存在
	> sismember myset "one" 
	//对两个集合求并集
	> sunion myset yourset
	
4.有序字符串集合（sorted sets）
	redis中的有序集合叫做zsets，操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等等
	//新增一个有序集合myzset，并加入一个元素baidu.com，给它赋予的序号是1：
	zadd myzset 1 baidu.com 
	//列出myzset的所有元素，同时列出其序号，可以看出myzset已经是有序的了。
	> zrange myzset 0 -1 with scores 
	
5.哈希（hashes）		
	//建立哈希，并赋值
	> HMSET user:001 username antirez password P1pp0 age 34 
	//列出哈希的内容
	> HGETALL user:001 
	//更改哈希中的某一个值
	> HSET user:001 password 12345

	
redis持久化 – 两种方式
RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；如果你对数据的完整性非常敏感，那么RDB方式就不太适合。
	 对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。
	 
AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，
	 只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。
	 通过配置redis.conf中的appendonly yes就可以打开AOF功能。
	 
其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。
如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。
同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。 
	
	
WATCH本身的作用是“监视key是否被改动过”，而且支持同时监视多个key，只要还没真正触发事务，
WATCH都会尽职尽责的监视，一旦发现某个key被修改了，在执行EXEC时就会返回nil，表示事务无法触发。

******************************************************************************************

